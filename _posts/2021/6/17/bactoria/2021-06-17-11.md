---
layout: post
title: "[클린아키텍처] 11장. DIP: 의존성 역전 원칙"
description: " "
date: 2021-06-17
tags: [클린아키텍처]
comments: true
share: true
---


## 11장. DIP: 의존성 역전 원칙 p.91~96

**소스 코드 의존성이** 추상에 의존하며 구체에는 의존하지 않는 시스템

`소스코드 의존성` 이 포인트인가?




## 새로 알게된 부분



단일 액터를 책임지는 코드를 함께 묶어주는 힘이다.

## 궁금한 부분

#### import는 클래스X, 인터페이스만O 
이거 엘레강트 오브젝트에 비슷한내용 있었던거 같은데?

=> 여기서는 매우 비현실적이라고 함.
String 클래스조차 클래스니..

but, String은 매우 안정적이다 를 말함.

#### DIP를 논할 땐 운영체제/안정성 보장된환경(플랫폼) 에 대해서는 무시?
변경되지 않는다면 의존할 수 있다.    
의존을 피하고자 하는 부분은 **변동성이 큰 구체적인 요소** 이다.  
변동성이 큰 구체적인 요소의 대표적인 예: 우리가 개발하는 모듈들

#### 구체 함수를 오버라이드 하지말라??
대체로 구체 함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게되며, 실제로는 그 의존성을 상속하게 된다. 라고하는데..

#### 팩토리
팩토리가 왜나와?  
팩토리 패턴 장점이 의존성 없애서 컴파일&배포 장점을 취하는건가?  

&nbsp;
&nbsp;

## 인상적이었던 부분

#### DIP를 모두 없앨 수 없다.
하지만, DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있다. 이를 통해 시스템의 나머지 부분과 분리할 수 있다.

main함수를 생각해봐라. 메인함수에서 모든걸 생성하고, 전역에 저장해둔다면?  
추상컴포넌트가 전역변수로 구체컴포넌트 인스턴스에 접근할 수 있다.

#### 변동성이 큰 구체 클래스로부터 상속하지 마라.
상속은 가장 강력하면서도 변경하기 어렵다.

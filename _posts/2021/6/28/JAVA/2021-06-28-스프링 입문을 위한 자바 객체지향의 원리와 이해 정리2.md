---
layout: post
title: "[java] 스프링 입문을 위한 자바 객체지향의 원리와 이해 정리 2"
description: " "
date: 2021-06-28
tags: [java]
comments: true
share: true
---

# 자바와 절차/구조적 프로그래밍

## 자바 프로그램의 개발과 구동

소프트웨어 개발 도구 - JDK(Java Development Kit) - JVM용 소프트웨어 개발 도구
운영체제 - JRE(Java Runtime Enviroment) - JVM용 OS
하드웨어 - JVM(Java Virtual Machine) - 가상의 컴퓨터

1. JDK를 통해 개발된 프로그램은
2. JRE에 의해 JVM 상에서 구동된다.

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRY5tkrTbgfMbT8EMNBRI25WtvMeKclk-RV5QH-IqQy2DQN0EpQ&usqp=CAU">

1. JDK는 자바 소스 컴파일러인 javac.exe를 포함하고 있다.
2. JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다.

자바가 이런 구조를 택한 이유는 기존 언어의 각 플랫폼(맥, 리눅스, 윈도우 95,7,8)별로 배포되는 설치 파일을 따로 준비해야 했던 불편함을 없애기 위해서다. -> write once run anywhere

<img src="https://t1.daumcdn.net/cfile/tistory/265907415592C0DB08">

보통 하나의 프로그램이 실행될 때 프로그램이 메모리를 사용하는 방식은 위 그림의 상단처럼 코드 실행영역과 데이터 저장영역으로 나누어져있다.

하지만 객체지향 프로그램에서는 데이터 저장영역을 위 그림의 하단 처럼 세 개의 영역으로 분할해서 사용한다.

## 자바에 존재하는 절차적, 구조적 프로그래밍의 유산

자바에 남아있는 절차적 프로그래밍을 한마디로 표현하자면 goto(실행 순서 이동)를 사용하지 말라는 것이다. goto를 사용하게 되면 프로그램 실행 순서가 굉장히 복잡해진다.

자바에 남아있는 구조적 프로그래밍은 함수를 쓰라는 것이다.

- 중복 코드를 한 곳에 모아서 관리할 수 있다.
- 논리를 함수 단위로 분리하여 이해하기 쉬운 코드의 작성이 가능하다.
- 공유 사용시 문제가 발생할 수 있기 때문에 전역 변수보다는 지역 변수를 써라

위의 두가지는 JAVA의 메서드에서 확인할 수 있다. 객체 지향 프로그래밍에서 제어 흐름을 이리저리 이동시키는 goto문과 함수의 사용이 사용되는 곳은 메서드이기 때문이다.

함수와 메서드는 다르지 않다.
절차/구조 프로그래밍에서는 함수라 불렸기 때문에 객체지향에서는 다르게 불러야 하지 않을까? 한게 메서드이다.

다만 차이점은 메서드는 반드시 클래스 정의 안에 존재해야 하고 함수는 클래스나 객체와 아무 관계가 없다.

## main 메서드: 스택 프레임

<img src="https://t1.daumcdn.net/cfile/tistory/260FD3415592C0DD37">
-> T 메모리

<br/>
<br/>

1. JRE는 먼저 프로그램 안에 main 메서드가 있는지 확인하다.
2. main 메서드가 확인되면 프로그램 실행을 위해 JRE가 JVM에 전원을 넣어 부팅시킨다.
3. 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행한다.
4. JVM은 전처리라는 과정을 가장 먼저 실행한다.
   1. java.lang 패키지를 T 메모리의 스태틱 영역에 가져다 놓는다.
   2. 개발자가 작성한 모든 클래스와 임포트 패키지 역시 스태틱 영역에 가져다 놓는다.

\*\*전처리과정

1. java.lang 패키지를 T 메모리의 스태틱 영역에 배치한다.
2. import 된 패키지를 T 메모리의 스태틱 영역에 배치한다.
3. 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치한다.

1) 클래스 내부의 메서드를 여는 중괄호("{")를 만날 때마다 T 메모리의 Stack에 해당 메소드의 스택 프레임이 하나씩 생긴다.
2) 해당 메소드가 받는 인자를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보하게 된다.
3) 메서드의 끝을 알리는 닫는 중괄호("}")를 만나면 스택 프레임이 소멸된다.

\*\*메인 메서드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다.

## 변수와 메모리

메서드 내에서 `int m`과 같은 명령어를 받았을 때 이는 해당 메서드의 스택 프레임 안에 밑에서부터 차곡 차곡 LIFO 형태로 저장된다.

`int m = 21`은 두 개의 명령 문이다. 변수를 선언하는 명령문과 변수에 값을 할당하는 명령문.

## 블록 구문과 메모리: 블록 스택 프레임

메서드 내에서 `if`문을 사용하면 해당 메서드의 스택 프레임내에 if문의 스택 프레임이 중첩되어 생긴다.

## 지역변수와 메모리

지역변수는 스태틱, 스택, 힙 영역에 모두 존재한다.
클래스 멤버 변수, 지역변수, 객체 멤버 변수로 이름을 갖고 있다.

### 클래스 멤버 변수

- 스태틱 영역에서 일생을 보내며 JVM이 종료될 때까지 고정된 상태로 그 자리를 지킨다.

### 지역변수

- 스택 영역(스택 프레임)에서 일생을 보내며 스택 프레임이 소멸되면 같이 사라진다.

### 객체 멤버 변수

- 힙에서 일생을 보내며 객체와 함께 가비지 컬렉터라는 메모리 회수기에 의해 일생을 마치게 된다.

## 메서드 호출과 메모리: 메서드 스택 프레임2

다른 메서드가 메인 메서드가 실행되고 있는 동안 T 메모리의 스택에 있는 메인 메서드의 스택 프레임에서 변수를 참조할 수 없어야 하는 이유

- 그것이 이치에 맞다. 메서드는 서로의 고유 공간이다.
- 포인터 문제 때문이다. 해당 변수를 참조하기 위해서는 메인 메서드 내부의 지역 변수가 저장된 위치를 알아야 하는데, 이때 포인터가 필요하지만 JAVA가 가장 환영받는 이유는 포인터가 없다는 부분이다.
- JAVA에서 메서드를 호출시 인자로 전달되는 것은 변수 자체가 아니라 변수가 지정한 값 만을 복제해서 전달하는 Call By Value이기 때문에 불가하다.

## 전역변수와 메모리

- 스택 프레임에 종속적인 지역변수
- 스택 프레임에 독립적인 전역변수

전역변수 사용은 지양, 하지만 읽기전용으로 값을 공유해서 전역 상수로 쓰는 것은 추천

## 멀티 스레드, 멀티 프로세스

<img src="https://mblogthumb-phinf.pstatic.net/20160605_158/mals93_1465132479088M2CDj_PNG/%B1%D7%B8%B21.png?type=w800">

멀티프로세스는 각자의 T 메모리가 있고 고유의 공간을 갖고 있다. 다만 메모리 사용이 크다.

멀티스레드는 하나의 T 메모리만 사용하며 스택 영역만을 분할해서 사용하고 스태틱, 힙영역은 공유해서 사용한다. 다만 메모리 사용 적다.

멀티 스레드에서 전역변수 사용은 에러를 일으킬 확률이 크다.

## 정리 객체 지향은 절차, 구조적 프로그래밍의 어깨를 딛고

메서드의 로직 설계 방법은 NS 다이어그램이다.

스태틱: 클래스들의 놀이터
스택: 메서드들의 놀이터
힙: 객체들의 놀이터

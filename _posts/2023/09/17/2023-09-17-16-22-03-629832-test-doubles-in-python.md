---
layout: post
title: "Test doubles in Python"
description: " "
date: 2023-09-17
tags: [Testing]
comments: true
share: true
---

Testing is an essential part of software development as it helps identify bugs and ensure the correctness of the code. During testing, it is often necessary to replace real dependencies such as databases or external services with fake objects that simulate their behavior. These fake objects are called "test doubles."

In Python, there are different types of test doubles that can be used based on the specific testing needs. Let's explore a few commonly used test doubles.

## 1. Stub

A stub is a test double that provides predefined responses to method calls made during the test. It is used to simulate specific behavior of an object and set up conditions for testing. Stubs are typically used when the code being tested interacts with external dependencies.

```python
import unittest
from unittest.mock import MagicMock

class PaymentGateway:
    def process_payment(self, amount):
        # Perform some payment processing logic
        return True

class Order:
    def __init__(self, payment_gateway):
        self.payment_gateway = payment_gateway

    def place_order(self, amount):
        return self.payment_gateway.process_payment(amount)

class TestOrder(unittest.TestCase):
    def test_place_order(self):
        # Create a stub payment gateway
        payment_gateway_stub = MagicMock()
        payment_gateway_stub.process_payment.return_value = True

        # Create an order object with the stub payment gateway
        order = Order(payment_gateway_stub)

        # Test placing an order
        result = order.place_order(100)

        self.assertTrue(result)
```

In the above example, the `PaymentGateway` class represents the real payment gateway. The `Order` class depends on the `PaymentGateway` object to process payments. During testing, we replace the real payment gateway with a stub object `payment_gateway_stub` using the `MagicMock` class from the `unittest.mock` module. The stub is configured to return a predetermined response when the `process_payment` method is called.

## 2. Mock

A mock is a test double that allows us to verify interactions between objects. It records and verifies method calls made during the test to ensure the code behaves as expected. Mocks are often used to verify that certain methods are called with specific arguments or called a certain number of times.

```python
import unittest
from unittest.mock import Mock

class EmailService:
    def send_email(self, recipient, subject, message):
        # Send email to recipient
        return True

class User:
    def __init__(self, email_service):
        self.email_service = email_service

    def register(self, name, email):
        # Perform user registration logic
        self.email_service.send_email(email, 'Welcome', 'Welcome to our platform!')

class TestUser(unittest.TestCase):
    def test_register(self):
        # Create a mock email service
        email_service_mock = Mock()

        # Create a user object with the mock email service
        user = User(email_service_mock)

        # Test user registration
        user.register('John Doe', 'johndoe@example.com')

        # Verify that send_email method was called with the expected arguments
        email_service_mock.send_email.assert_called_once_with('johndoe@example.com', 'Welcome', 'Welcome to our platform!')
```

In the above example, the `EmailService` class represents the real email service. During testing, we create a mock object `email_service_mock` using the `Mock` class from the `unittest.mock` module. We then pass this mock object to the `User` class. After calling the `register` method, we verify that the `send_email` method of the mock object was called with the expected arguments using the `assert_called_once_with` method.

Remember to `import unittest` and `import mock` at the beginning of your code for both examples.

These are just a couple of examples of test doubles in Python. By using stubs, mocks, and other test doubles, we can isolate our code during testing and make test cases more reliable and focused.

#Python #Testing
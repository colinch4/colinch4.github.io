---
layout: post
title: "Polymorphism in Python"
description: " "
date: 2023-09-13
tags: [python, polymorphism]
comments: true
share: true
---

Polymorphism is a fundamental concept in object-oriented programming (OOP) that allows objects of different classes to be treated as if they were objects of the same class. It allows for code to be written that can work with objects in a generic way, without needing to know their specific class type.

Python, being an object-oriented language, supports polymorphism through a mix of dynamic typing and duck typing. This means that objects are not required to inherit from a particular superclass or implement a specific interface in order to be polymorphic.

## Polymorphism Through Inheritance

Polymorphism in Python can be achieved through inheritance. When a class inherits from another class, it can override its methods and provide its own implementation. This allows objects of the subclasses to be used interchangeably with objects of the superclass.

```python
class Animal:
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        print("Woof!")

class Cat(Animal):
    def make_sound(self):
        print("Meow!")

def make_animal_sound(animal):
    animal.make_sound()

dog = Dog()
cat = Cat()

make_animal_sound(dog)  # Output: Woof!
make_animal_sound(cat)  # Output: Meow!
```

In the example above, we have an `Animal` class with a `make_sound` method. The `Dog` and `Cat` classes inherit from `Animal` and override the `make_sound` method. The `make_animal_sound` function takes an `Animal` object as a parameter and calls its `make_sound` method, regardless of whether it is a `Dog` or `Cat` object. This demonstrates polymorphism in action.

## Polymorphism Through Duck Typing

In Python, polymorphism is not limited to inheritance-based polymorphism. It also supports duck typing, which is a way of determining an object's suitability based on its behavior rather than its class type.

```python
class Duck:
    def quack(self):
        print("Quack!")

class Person:
    def quack(self):
        print("I can quack like a duck!")

def make_quack_sound(entity):
    entity.quack()

duck = Duck()
person = Person()

make_quack_sound(duck)   # Output: Quack!
make_quack_sound(person) # Output: I can quack like a duck!
```

In the example above, we have a `Duck` class and a `Person` class, both of which have a `quack` method. The `make_quack_sound` function takes an object and calls its `quack` method. Even though `duck` and `person` are not related by inheritance, they can still be used polymorphically because they provide the required behavior.

## Conclusion

Polymorphism is a powerful concept in object-oriented programming that allows for flexible and reusable code. In Python, polymorphism can be achieved through inheritance-based polymorphism and duck typing.

Using polymorphism, we can write code that can work with objects of different classes in a generic way. This can lead to cleaner and more maintainable code, as it reduces the need for repetitive and specific code for each class.

#python #polymorphism